// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.26;

import {IArk} from "../../src/interfaces/IArk.sol";

import {Constants} from "../../src/utils/Constants.sol";
import {Test, console} from "forge-std/Test.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

/// @title Ark Test Helpers
/// @notice Provides helper functions for testing Ark contracts
contract ArkTestHelpers is Test, Constants {
    using ECDSA for bytes32;
    /// @notice Mocks the return value of `totalAssets` for a given Ark contract
    /// @param contractAddress The address of the Ark contract whose `totalAssets` function is to be mocked
    /// @param returnValue The value to return when `totalAssets` is called
    function mockArkTotalAssets(
        address contractAddress,
        uint256 returnValue
    ) public {
        vm.mockCall(
            contractAddress,
            abi.encodeWithSelector(IArk(contractAddress).totalAssets.selector),
            abi.encode(returnValue)
        );
    }

    /**
     * @notice Mocks the return value of `depositCap` for a given Ark contract
     * @param contractAddress The address of the Ark contract whose `totalAssets` function is to be mocked
     * @param returnValue The value to return when `depositCap` is called
     */
    function mockArkMaxAllocation(
        address contractAddress,
        uint256 returnValue
    ) public {
        vm.mockCall(
            contractAddress,
            abi.encodeWithSelector(IArk(contractAddress).depositCap.selector),
            abi.encode(returnValue)
        );
    }

    /**
     * @dev Mocks the `maxRebalanceOutflow` function of the `IArk` contract.
     * @param ark The address of the `IArk` contract.
     * @param maxRebalanceOutflow The value to be passed to the `maxRebalanceOutflow` function.
     */
    function mockArkMaxRebalanceOutflow(
        address ark,
        uint256 maxRebalanceOutflow
    ) internal {
        vm.mockCall(
            ark,
            abi.encodeWithSelector(IArk.maxRebalanceOutflow.selector),
            abi.encode(maxRebalanceOutflow)
        );
    }

    /**
     * @dev Mocks the `maxRebalanceInflow` function of the `IArk` contract.
     * @param ark The address of the `IArk` contract.
     * @param maxRebalanceInflow The value to be passed to the `maxRebalanceInflow` function.
     */
    function mockArkMoveToMax(
        address ark,
        uint256 maxRebalanceInflow
    ) internal {
        vm.mockCall(
            ark,
            abi.encodeWithSelector(IArk.maxRebalanceInflow.selector),
            abi.encode(maxRebalanceInflow)
        );
    }

    /**
     * @dev Verifies that a given signature matches the expected signer for a given message.
     * @param message The hashed message that was signed.
     * @param signature The signature to verify, which must be 65 bytes long.
     * @param expectedSigner The address of the expected signer.
     * @return bool Returns true if the signature is valid and was created by the expected signer, false otherwise.
     * @notice The signature must be in the standard format {r, s, v} where r and s are 32 bytes each and v is 1 byte.
     */
    function verifySignature(
        bytes32 message,
        bytes memory signature,
        address expectedSigner
    ) public pure returns (bool) {
        require(signature.length == 65, "Invalid signature length");
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        address recoveredSigner = ecrecover(message, v, r, s);
        return recoveredSigner == expectedSigner;
    }

    /**
     * @dev Signs a given message using the provided private key.
     * @param privateKey The private key used to sign the message.
     * @param message The message to be signed.
     * @return signature The complete signature in bytes format.
     */
    function signMessage(
        uint256 privateKey,
        string memory message
    ) public pure returns (bytes memory signature) {
        bytes32 messageHash = getEthSignedMessageHash(message);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);
        return abi.encodePacked(r, s, v);
    }

    /**
     * @dev Verifies that a given signature corresponds to a given message and signer.
     * @param message The original message that was signed.
     * @param signature The signature generated by signing the message.
     * @param signer The address of the signer that is expected to have created the signature.
     * @return bool Returns true if the signature is valid and was created by the given signer, otherwise false.
     */
    function verifySignature(
        string memory message,
        bytes memory signature,
        address signer
    ) public pure returns (bool) {
        bytes32 messageHash = getEthSignedMessageHash(message);
        return recoverSigner(messageHash, signature) == signer;
    }

    /**
     * @dev Generates the Ethereum signed message hash for a given message.
     * This function uses the keccak256 hashing algorithm to encode the message.
     *
     * @param message The message to be hashed.
     * @return The Ethereum signed message hash as a bytes32 value.
     */
    function getEthSignedMessageHash(
        string memory message
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(message));
    }

    /**
     * @dev Recovers the address that signed the given message hash with the provided signature.
     * @param messageHash The hash of the signed message.
     * @param signature The signature generated by signing the message hash.
     * @return The address that signed the message hash.
     */
    function recoverSigner(
        bytes32 messageHash,
        bytes memory signature
    ) public pure returns (address) {
        return messageHash.recover(signature);
    }

    function test() public {}
}
